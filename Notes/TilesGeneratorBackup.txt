using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine;

public class TilesGenerator : MonoBehaviour
{
    private EndlessCavern endlessCavern;
    //Probability of a True cell in initialization.
    private const float P = 0.45f;
    //Whether the boundary cells are considered true or false
    private const bool E = true;
    //Birth Rate
    private const int B = 4;
    //Death Rate
    private const int D = 4;
    private const int ITERATIONS = 3;

    private void Start()
    {
        endlessCavern = GameObject.Find("Cavern Generator").GetComponent<EndlessCavern>();
    }
    public static bool[,] GenerateTiles(int chunkX, int chunkY, bool neighbor = false)
    {
        int chunkSize = EndlessCavern.CHUNK_SIZE;
        System.Random prng = new System.Random(EndlessCavern.SEED);
        prng = new System.Random(prng.Next(-100000, 100000) + chunkX);
        prng = new System.Random(prng.Next(-100000, 100000) + chunkY);
        int chunkSeed = prng.Next(-100000, 100000);
        UnityEngine.Random.InitState(chunkSeed);

        bool[,] initialTiles = new bool[chunkSize, chunkSize];

        for (int y = 0; y < chunkSize; y++)
        {
            for (int x = 0; x < chunkSize; x++)
            {
                initialTiles[x, y] = UnityEngine.Random.value < P;
            }
        }

        if (neighbor)
            return initialTiles;

        bool[,] iterativeTiles = new bool[chunkSize, chunkSize];

        for (int i = 0; i < ITERATIONS; i++)
        {
            for (int y = 0; y < chunkSize; y++)
            {
                for (int x = 0; x < chunkSize; x++)
                {
                    int t = 0;
                    bool l, uL, u, uR, r, dR, d, dL;
                    l = x == 0 ? E : initialTiles[x - 1, y];
                    uL = x == 0 || (y == chunkSize - 1) ? E : initialTiles[x - 1, y + 1];
                    u = (y == chunkSize - 1) ? E : initialTiles[x, y + 1];
                    uR = (x == chunkSize - 1) || (y == chunkSize - 1) ? E : initialTiles[x + 1, y + 1];
                    r = (x == chunkSize - 1) ? E : initialTiles[x + 1, y];
                    dR = (x == chunkSize - 1) || y == 0 ? E : initialTiles[x + 1, y - 1];
                    d = y == 0 ? E : initialTiles[x, y - 1];
                    dL = y == 0 || x == 0 ? E : initialTiles[x - 1, y - 1];

                    t += Convert.ToInt32(l) + Convert.ToInt32(uL) + Convert.ToInt32(u) + Convert.ToInt32(uR) + Convert.ToInt32(r) + Convert.ToInt32(dR) + Convert.ToInt32(d) + Convert.ToInt32(dL);

                    if (initialTiles[x, y])
                    {
                        iterativeTiles[x, y] = !(t < D);
                    }
                    else
                    {
                        iterativeTiles[x, y] = t > B;
                    }
                }
            }
            initialTiles = iterativeTiles;
        }

        return iterativeTiles;
    }

    public bool[,] GenerateSeamlessTiles(int chunkX, int chunkY)
    {
        int chunkSize = EndlessCavern.CHUNK_SIZE;

        bool[,] initialMainTiles = GenerateTiles(chunkX, chunkY, true);
        bool[,] initialUpTiles = GenerateTiles(chunkX, chunkY + 1, true);
        bool[,] initialDownTiles = GenerateTiles(chunkX, chunkY - 1, true);
        bool[,] initialLeftTiles = GenerateTiles(chunkX - 1, chunkY, true);
        bool[,] initialRightTiles = GenerateTiles(chunkX + 1, chunkY, true);

        bool[,] iterativeMainTiles = new bool[chunkSize, chunkSize];
        bool[,] iterativeUpTiles = new bool[chunkSize, chunkSize];
        bool[,] iterativeDownTiles = new bool[chunkSize, chunkSize];
        bool[,] iterativeLeftTiles = new bool[chunkSize, chunkSize];
        bool[,] iterativeRightTiles = new bool[chunkSize, chunkSize];

        for (int i = 0; i < ITERATIONS; i++)
        {
            //Going through top chunk
            for (int y = 0; y < chunkSize; y++)
            {
                for (int x = 0; x < chunkSize; x++)
                {
                    int t = 0;
                    bool l, uL, u, uR, r, dR, d, dL;

                    if (y == 0)
                    {
                        dR = x == chunkSize - 1 ? initialRightTiles[0, chunkSize - 1] : initialDownTiles[x + 1, chunkSize - 1];
                        d = initialDownTiles[x, chunkSize - 1];
                        dL = x == 0 ? initialLeftTiles[chunkSize - 1, chunkSize - 1] : initialDownTiles[x - 1, chunkSize - 1];
                    }
                    else
                    {
                        dR = (x == chunkSize - 1) || y == 0 ? E : initialUpTiles[x + 1, y - 1];
                        d = y == 0 ? E : initialUpTiles[x, y - 1];
                        dL = y == 0 || x == 0 ? E : initialUpTiles[x - 1, y - 1];
                    }

                    l = x == 0 ? E : initialUpTiles[x - 1, y];
                    uL = x == 0 || (y == chunkSize - 1) ? E : initialUpTiles[x - 1, y + 1];
                    u = (y == chunkSize - 1) ? E : initialUpTiles[x, y + 1];
                    uR = (x == chunkSize - 1) || (y == chunkSize - 1) ? E : initialUpTiles[x + 1, y + 1];
                    r = (x == chunkSize - 1) ? E : initialUpTiles[x + 1, y];

                    t += Convert.ToInt32(l) + Convert.ToInt32(uL) + Convert.ToInt32(u) + Convert.ToInt32(uR) + Convert.ToInt32(r) + Convert.ToInt32(dR) + Convert.ToInt32(d) + Convert.ToInt32(dL);

                    if (initialUpTiles[x, y])
                    {
                        iterativeUpTiles[x, y] = !(t < D);
                    }
                    else
                    {
                        iterativeUpTiles[x, y] = t > B;
                    }
                }
            }
            //Going through left chunk
            for (int y = 0; y < chunkSize; y++)
            {
                for (int x = 0; x < chunkSize; x++)
                {
                    int t = 0;
                    bool l, uL, u, uR, r, dR, d, dL;

                    if (x == chunkSize - 1)
                    {
                        uR = y == chunkSize - 1 ? initialUpTiles[0, 0] : initialMainTiles[0, y + 1];
                        r = initialMainTiles[0, y];
                        dR = y == 0 ? initialDownTiles[0, chunkSize - 1] : initialMainTiles[0, y - 1];
                    }
                    else
                    {
                        uR = (x == chunkSize - 1) || (y == chunkSize - 1) ? E : initialLeftTiles[x + 1, y + 1];
                        r = (x == chunkSize - 1) ? E : initialLeftTiles[x + 1, y];
                        dR = (x == chunkSize - 1) || y == 0 ? E : initialLeftTiles[x + 1, y - 1];
                    }

                    l = x == 0 ? E : initialLeftTiles[x - 1, y];
                    uL = x == 0 || (y == chunkSize - 1) ? E : initialLeftTiles[x - 1, y + 1];
                    u = (y == chunkSize - 1) ? E : initialLeftTiles[x, y + 1];
                    d = y == 0 ? E : initialLeftTiles[x, y - 1];
                    dL = y == 0 || x == 0 ? E : initialLeftTiles[x - 1, y - 1];

                    t += Convert.ToInt32(l) + Convert.ToInt32(uL) + Convert.ToInt32(u) + Convert.ToInt32(uR) + Convert.ToInt32(r) + Convert.ToInt32(dR) + Convert.ToInt32(d) + Convert.ToInt32(dL);

                    if (initialLeftTiles[x, y])
                    {
                        iterativeLeftTiles[x, y] = !(t < D);
                    }
                    else
                    {
                        iterativeLeftTiles[x, y] = t > B;
                    }
                }
            }
            //Going through main chunk
            for (int y = 0; y < chunkSize; y++)
            {
                for (int x = 0; x < chunkSize; x++)
                {
                    int t = 0;
                    bool l, uL, u, uR, r, dR, d, dL;

                    if (x == 0 && y == 0)
                    {
                        dL = E;
                        if (initialLeftTiles != null)
                        {
                            l = initialLeftTiles[chunkSize - 1, y];
                            uL = initialLeftTiles[chunkSize - 1, y + 1];
                        }
                        else
                        {
                            l = uL = E;
                        }
                        if (initialDownTiles != null) {
                            d = initialDownTiles[x, chunkSize - 1];
                            dR = initialDownTiles[x + 1, chunkSize - 1];
                        }
                        else
                        {
                            d = dR = E;
                        }
                        //u, uR, r
                        u = initialMainTiles[x, y + 1];
                        uR = initialMainTiles[x + 1, y + 1];
                        r = initialMainTiles[x + 1, y];
                    }
                    else if (x == chunkSize - 1 && y == chunkSize - 1)
                    {
                        uR = E;
                        if (initialRightTiles != null)
                        {
                            r = initialRightTiles[0, y];
                            dR = initialRightTiles[0, y - 1];
                        }
                        else
                        {
                            r = dR = E;
                        }
                        if (initialUpTiles != null)
                        {
                            u = initialUpTiles[x, 0];
                            uL = initialUpTiles[x - 1, 0];
                        }
                        else
                        {
                            u = uL = E;
                        }
                        //l, d, dL
                        l = initialMainTiles[x - 1, y];
                        d = initialMainTiles[x, y - 1];
                        dL = initialMainTiles[x - 1, y - 1];
                    }
                    else if (x == 0 && y == chunkSize - 1)
                    {
                        uL = E;
                        if (initialLeftTiles != null)
                        {
                            l = initialLeftTiles[chunkSize - 1, y];
                            dL = initialLeftTiles[chunkSize - 1, y - 1];
                        }
                        else
                        {
                            l = dL = E;
                        }
                        if (initialUpTiles != null)
                        {
                            u = initialUpTiles[x, 0];
                            uR = initialUpTiles[x + 1, 0];
                        }
                        else
                        {
                            u = uR = E;
                        }
                        //r, dR, d
                        r = initialMainTiles[x + 1, y];
                        dR = initialMainTiles[x + 1, y - 1];
                        d = initialMainTiles[x, y - 1];
                    }
                    else if (x == chunkSize - 1 && y == 0)
                    {
                        dR = E;
                        if (initialRightTiles != null)
                        {
                            r = initialRightTiles[0, y];
                            uR = initialRightTiles[0, y + 1];
                        }
                        else
                        {
                            r = uR = E;
                        }
                        if (initialDownTiles != null)
                        {
                            d = initialDownTiles[x, chunkSize - 1];
                            dL = initialDownTiles[x - 1, chunkSize - 1];
                        }
                        else
                        {
                            d = dL = E;
                        }
                        //l, uL, u
                        l = initialMainTiles[x - 1, y];
                        uL = initialMainTiles[x - 1, y + 1];
                        u = initialMainTiles[x, y + 1];
                    }
                    else if (x == 0)
                    {
                        if (initialLeftTiles != null)
                        {
                            l = initialLeftTiles[chunkSize - 1, y];
                            uL = initialLeftTiles[chunkSize - 1, y + 1];
                            dL = initialLeftTiles[chunkSize - 1, y + 1];
                        }
                        else
                        {
                            l = uL = dL = E;
                        }
                        u = initialMainTiles[x, y + 1];
                        uR = initialMainTiles[x + 1, y + 1];
                        r = initialMainTiles[x + 1, y];
                        dR = initialMainTiles[x + 1, y - 1];
                        d = initialMainTiles[x, y - 1];
                    }
                    else if (y == 0)
                    {
                        if (initialDownTiles != null)
                        {
                            d = initialDownTiles[x, chunkSize - 1];
                            dR = initialDownTiles[x + 1, chunkSize - 1];
                            dL = initialDownTiles[x - 1, chunkSize - 1];
                        }
                        else
                        {
                            d = dL = dR = E;
                        }
                        l = initialMainTiles[x - 1, y];
                        uL = initialMainTiles[x - 1, y + 1];
                        u = initialMainTiles[x, y + 1];
                        uR = initialMainTiles[x + 1, y + 1];
                        r = initialMainTiles[x + 1, y];
                    }
                    else if (x == chunkSize - 1)
                    {
                        if (initialRightTiles != null)
                        {
                            r = initialRightTiles[0, y];
                            dR = initialRightTiles[0, y - 1];
                            uR = initialRightTiles[0, y + 1];
                        }
                        else
                        {
                            r = uR = dR = E;
                        }
                        l = initialMainTiles[x - 1, y];
                        uL = initialMainTiles[x - 1, y + 1];
                        u = initialMainTiles[x, y + 1];
                        d = initialMainTiles[x, y - 1];
                        dL = initialMainTiles[x - 1, y - 1];
                    }
                    else if (y == chunkSize - 1)
                    {
                        if (initialUpTiles != null)
                        {
                            u = initialUpTiles[x, 0];
                            uL = initialUpTiles[x - 1, 0];
                            uR = initialUpTiles[x + 1, 0];
                        }
                        else
                        {
                            u = uR = uL = E;
                        }
                        l = initialMainTiles[x - 1, y];
                        r = initialMainTiles[x + 1, y];
                        dR = initialMainTiles[x + 1, y - 1];
                        d = initialMainTiles[x, y - 1];
                        dL = initialMainTiles[x - 1, y - 1];
                    }
                    else
                    {
                        l = initialMainTiles[x - 1, y];
                        uL = initialMainTiles[x - 1, y + 1];
                        u = initialMainTiles[x, y + 1];
                        uR = initialMainTiles[x + 1, y + 1];
                        r = initialMainTiles[x + 1, y];
                        dR = initialMainTiles[x + 1, y - 1];
                        d = initialMainTiles[x, y - 1];
                        dL = initialMainTiles[x - 1, y - 1];
                    }

                    t += Convert.ToInt32(l) + Convert.ToInt32(uL) + Convert.ToInt32(u) + Convert.ToInt32(uR) + Convert.ToInt32(r) + Convert.ToInt32(dR) + Convert.ToInt32(d) + Convert.ToInt32(dL);

                    if (initialMainTiles[x, y])
                    {
                        iterativeMainTiles[x, y] = !(t < D);
                    }
                    else
                    {
                        iterativeMainTiles[x, y] = t > B;
                    }
                }
            }
            //Going through right chunk
            for (int y = 0; y < chunkSize; y++)
            {
                for (int x = 0; x < chunkSize; x++)
                {
                    int t = 0;
                    bool l, uL, u, uR, r, dR, d, dL;

                    if (x == 0)
                    {
                        l = initialMainTiles[chunkSize - 1, y];
                        uL = y == chunkSize - 1 ? initialUpTiles[chunkSize - 1, 0] : initialMainTiles[chunkSize - 1, y + 1];
                        dL = y == 0 ? initialDownTiles[chunkSize - 1, chunkSize - 1] : initialMainTiles[chunkSize - 1, y - 1];
                    }
                    else
                    {
                        l = x == 0 ? E : initialRightTiles[x - 1, y];
                        uL = x == 0 || (y == chunkSize - 1) ? E : initialRightTiles[x - 1, y + 1];
                        dL = y == 0 || x == 0 ? E : initialRightTiles[x - 1, y - 1];
                    }

                    u = (y == chunkSize - 1) ? E : initialRightTiles[x, y + 1];
                    uR = (x == chunkSize - 1) || (y == chunkSize - 1) ? E : initialRightTiles[x + 1, y + 1];
                    r = (x == chunkSize - 1) ? E : initialRightTiles[x + 1, y];
                    dR = (x == chunkSize - 1) || y == 0 ? E : initialRightTiles[x + 1, y - 1];
                    d = y == 0 ? E : initialRightTiles[x, y - 1];

                    t += Convert.ToInt32(l) + Convert.ToInt32(uL) + Convert.ToInt32(u) + Convert.ToInt32(uR) + Convert.ToInt32(r) + Convert.ToInt32(dR) + Convert.ToInt32(d) + Convert.ToInt32(dL);

                    if (initialRightTiles[x, y])
                    {
                        iterativeRightTiles[x, y] = !(t < D);
                    }
                    else
                    {
                        iterativeRightTiles[x, y] = t > B;
                    }
                }
            }
            //Going through right chunk
            for (int y = 0; y < chunkSize; y++)
            {
                for (int x = 0; x < chunkSize; x++)
                {
                    int t = 0;
                    bool l, uL, u, uR, r, dR, d, dL;

                    if (y == chunkSize - 1)
                    {
                        uL
                    }
                    else
                    {
                        uL = x == 0 || (y == chunkSize - 1) ? E : initialDownTiles[x - 1, y + 1];
                        u = (y == chunkSize - 1) ? E : initialDownTiles[x, y + 1];
                        uR = (x == chunkSize - 1) || (y == chunkSize - 1) ? E : initialDownTiles[x + 1, y + 1];
                    }

                    l = x == 0 ? E : initialDownTiles[x - 1, y];
                    r = (x == chunkSize - 1) ? E : initialDownTiles[x + 1, y];
                    dR = (x == chunkSize - 1) || y == 0 ? E : initialDownTiles[x + 1, y - 1];
                    d = y == 0 ? E : initialDownTiles[x, y - 1];
                    dL = y == 0 || x == 0 ? E : initialDownTiles[x - 1, y - 1];

                    t += Convert.ToInt32(l) + Convert.ToInt32(uL) + Convert.ToInt32(u) + Convert.ToInt32(uR) + Convert.ToInt32(r) + Convert.ToInt32(dR) + Convert.ToInt32(d) + Convert.ToInt32(dL);

                    if (initialDownTiles[x, y])
                    {
                        iterativeDownTiles[x, y] = !(t < D);
                    }
                    else
                    {
                        iterativeDownTiles[x, y] = t > B;
                    }
                }
            }
            initialMainTiles = iterativeMainTiles;
        }

        return iterativeMainTiles;
    }
}
